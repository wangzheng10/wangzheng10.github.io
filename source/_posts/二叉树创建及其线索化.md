---
title: 二叉树创建及其线索化
date: 2022/4/15
categories:
- 数据结构
---

@[TOC](目录)

---

> 二叉树是n( n $\geqslant$ 0 )个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两个互不相交的、分别称为根节点的左子树和右子树的二叉树组成。

# 二叉链表

因为二叉数每个结点最多只有两个孩子，所以我们可以通过链表的方式表示，链表由一个数据域和两个指针域组成。

|     lchild     |  data  |     rchild     |
| :------------: | :----: | :------------: |
| 指向左孩子指针 | 数据域 | 指向右孩子指针 |



```c
typedef struct BiTNode
{
    char data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

---

## 二叉树创建

通常以前序的方式创建二叉树，即先写某一结点的数据，再写其左孩子数据，最后写其右孩子数据。

```c
/********************************************************************************************\
*function: 通过键盘输入以前序的方式创建二叉树
*intput: BiTree *Tree -- BiTNode的二级指针（函数的指针只传递其内容，因此利用指针申请内存，应使用二级指针）
*output: none
*return: void
\********************************************************************************************/
void CreateBiTree(BiTree *Tree)
{
    char str;
    scanf("%c", &str); //从键盘读取字符
    if (str == '#') //以#表示空结点
    {
        *Tree = NULL;
    }
    else
    {
        *Tree = (BiTree )malloc(sizeof(BiTNode)); //为新结点申请内存
        if(*Tree == NULL)
        {
            exit(1); //申请内存失败，中断程序运行
        }
        (*Tree)->data = str; //写入此结点数据
        CreateBiTree(&(*Tree)->lchild); //写左孩子数据
        CreateBiTree(&(*Tree)->rchild); //写右孩子数据
    }
}
```



---



## 二叉树遍历

通常有3种方式遍历二叉树，即前序、中序、后序的方法。

**前序**：先读结点数据，再读左孩子的数据，最后读右孩子的数据；

**中序**：先读左孩子的数据，再读结点的数据，最后读右孩子数据；

**后序**：先读左孩子的数据，再读右孩子的数据，最后读结点的数据。

这里以前序遍历为例，中序和后序只要调换结点数据与其孩子的遍历顺序即可。

```c
/********************************************************************************************\
*function: 以前序的方式遍历二叉树，并将其打印
*intput: BiTree Tree -- BiTNode的一级指针
*output: none
*return: void
\********************************************************************************************/
void PreOrderTraverse(BiTree Tree)
{
    if (Tree == NULL) //判断是否是空指针
    {
        return;
    }
    printf("%c ", Tree->data); //输出此结点数据
    PreOrderTraverse(Tree->lchild); //遍历左孩子
    PreOrderTraverse(Tree->rchild); //遍历右孩子
}
```



我们可以尝试去编译一下二叉树创建和遍历函数：

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    BiTree OneTree; //创建结点指针
    CreateBiTree(&OneTree); //前序创建二叉树
    printf("前序遍历：");
    PreOrderTraverse(OneTree); //前序遍历二叉树
    printf("\n中序遍历：");
    InOrderTraverse(OneTree); //中序遍历二叉树
    printf("\n后序遍历：");
    PostOrderTraverse(OneTree); //后序遍历二叉树
    return 0;
}
```

输出：

```c
abc###de##f##
前序遍历：a b c d e f
中序遍历：c b a e d f
后序遍历：c b e f d a
        a
      /	  \
    b      d
   /      / \
  c      e   f 
```

---

---

# 线索二叉树

上面利用链表建立的二叉树中存在大量的空指针，每一个`#`都是空指针，造成很大的空间浪费。因此我们可以利用这些空指针来表示某一结点的前驱和后继。

为了区别指针域指向的是其孩子还是前驱或后继，因此增加两个标志域。如果左标志域为0，则左指针域指向左孩子，如果为1，则为指向前驱，右标志域相同。
|     lchild     |  lflag |  data  |  rflag |     rchild     |
| :------------: | :----: | :----: | :----: | :------------: |
| 指向左孩子指针 | 左标志域| 数据域 | 右标志域 | 指向右孩子指针 |

下图中，以中序遍历的方式，实线表示指向结点的孩子，虚线表示指向结点的前驱或者后继。

![线索二叉树](https://img-blog.csdnimg.cn/5d70b135c9354d56a50d84d525d86fa4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Iul5oKy5rWq,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)

---

## 线索二叉树的创建

结点的结构定义如下：
```c
typedef enum
{
    Link = 0,
    Thread
}PointerFlag;

typedef struct BiThrNode
{
    char data; //数据域
    struct BiThrNode *lchild, *rchild; //左右孩子指针
    PointerFlag LFlag; //左标志
    PointerFlag RFlag; //右标志
}BiThrNode, *BiThrTree;

BiThrTree Pre = NULL; //前驱指针
```
---

首先按照先序的方式创建二叉树：

```c
/********************************************************************************************\
*function: 先序创建二叉树
*intput: BiThrTree *T -- BiThrNode的二级指针
*output: none
*return: void
\********************************************************************************************/
void CreateBiTree(BiThrTree *T)
{
    char str;
    scanf("%c", &str);
    if (str == '#')
    {
        *T = NULL;
    }
    else
    {
        *T = (BiThrTree )malloc(sizeof(BiThrNode));
        if(*T == NULL)
        {
            exit(1);
        }

        (*T)->data = str;
        (*T)->LFlag = Link; //创建时，先使标志位均表示指向孩子
        (*T)->RFlag = Link;
        CreateBiTree(&(*T)->lchild);
        CreateBiTree(&(*T)->rchild);
    }
}
```

---

然后以中序遍历的方式，线索化二叉树：
```c
/********************************************************************************************\
*function: 中序线索化二叉树
*intput: BiThrTree T -- BiThrNode的一级指针
*output: none
*return: void
\********************************************************************************************/
void InThreading(BiThrTree T)
{
    if (T == NULL)
    {
        return;
    }
    InThreading(T->lchild); //线索化左子树

    if (T->lchild == NULL) //当前节点没有左孩子
    {
        T->LFlag = Thread; //标志域改为前驱线索
        T->lchild = Pre; //左孩子指针指向前驱
    }

    if (Pre->rchild == NULL) //前驱结点没有右孩子
    {
        Pre->RFlag = Thread; //标志域改为后继线索
        Pre->rchild = T; //右孩子指针指向后继
    }
    Pre = T; //T即将指向下一结点，因此要使Pre指向当前结点

    InThreading(T->rchild); //线索化右子树
}
```

---

最后定义头指针，并连接头指针与二叉树：
```c
/********************************************************************************************\
*function: 创建头指针，并连接头指针与二叉树
*intput: BiThrTree T -- BiThrNode的一级指针
*output: none
*return: BiThree ThrHead -- 头指针（若为空树，则头指针为空指针）
\********************************************************************************************/
BiThrTree CreatInHreading(BiThrTree T)
{
     BiThrTree ThrHead;
     ThrHead = (BiThrNode *)malloc(sizeof(BiThrNode));//为头指针申请内存
     
     
     if (T == NULL)
     {
         ThrHead = NULL; // 若根结点为空，则ThrHead为空
     }

    else
    {
        Pre = ThrHead; // 将ThrHead赋给pre，pre为中序遍历当前结点的前驱
        
        InThreading(T); //二叉树中序线索化
        
        ThrHead->LFlag = Link;
        ThrHead->lchild = T; //头指针的左孩子指向二叉树的头结点
        
        Pre->RFlag = Thread;
        Pre->rchild = ThrHead; //中序线索树的最后一个结点后继为ThrHead头指针
        
        ThrHead->RFlag = Thread;
        ThrHead->rchild = Pre; // 头指针ThrHead的右孩子指向最后一个结点
    }
    
    return ThrHead; //返回头结点
}
```

---

## 中序遍历线索二叉树

```c
/********************************************************************************************\
*function: 中序遍历线索二叉树
*intput: BiThrTree Head -- 线索二叉树的头指针
*output: none
*return: void
\********************************************************************************************/
void InOrderTraverse_Thr(BiThrTree Head)
{
    BiThrTree p;
    p = Head->lchild;
    while (p != Head) //遍历结束时，p会指向头指针
    {
        while (p->LFlag == Link) //中序遍历的第一个结点
        {
            p = p->lchild;
        }
        
        printf("%c ", p->data);//打印第一个结点
        
        while ((p->RFlag == Thread) && (p->rchild != Head)) //有后继结点，且后继结点不是头指针
        {
            p = p->rchild; 
            printf("%c ", p->data); //打印后继结点
        }
        p = p->rchild; //p指向其右子树
    }
}

```

---

主函数如下：
```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    BiThrTree R;
    CreateBiTree(&R); //创建二叉树

    BiThrTree Head;
    Head = CreatInHreading(R); //中序线索化二叉树
    
    InOrderTraverse_Thr(Head); //中序遍历线索二叉树
    return 0;
}
```
输出：
```c
AB#D##C##
B D A C
```

**线索化二叉树充分的利用了指针域的空间，实现了双向遍历的功能，既可以从第一个结点开始向后遍历，又可以从最后一个结点开始向前遍历。**