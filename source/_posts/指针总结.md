---
title: C语言指针总结与应用
date: 2022/3/22
categories:
- C语言
---

@[TOC](目录)

---

# 前言

## 指针的定义
我们使用*表示指针，例如

```c
int *p; //定义一个指针P,指向的内容为int类型。
int *p[n]; //[]的优先级高于*，则p是一个长度为n的数组，数组内的元素为指针类型，指向的内容为int型。
int (*p)[n]; //指针p指向一个数组，数组内的元素为int类型。
int **p;  //二级指针，指针p指向*p，仍然是一个指针，*p指向的内容为int型，一般用于函数的形参。
int (*p)(int); //指针p指向一个函数，函数的形参类型为int，返回值为int。
```
指针的值代表的是地址，是指向的内存区的首地址，指针所占用的空间只受系统寻址位数影响，如果是32位系统，则指针占用4个字节，如果是16位系统，则占用2个字节。

---
---

# 指针的常用方法

1. 代指一个变量
```c
int a = 3;
int *p = &a;
*p = 4;
printf("%d", a); // a = 4
```

---

2. 表示数组
```c
int a[10];
int *p = a;
int i;
for (i = 0; i < 10; i++)
{
  *p++ = i;
  printf("%d", a[i]); // a[i] = i
}
```

---

3. 指向结构体
```c
struct PhoneParameter
{
  int m_Length;
  int m_Width;
  int m_Height;
}PhPar;

PhPar st_MyPhPar = {15, 7, 1};

int CalVolume(PhPar *pstPar)
{
  int Vol;
  Vol = pstPar->m_Length * pstPar->m_Width * pstPar->m_Height;
  return Vol;
}

printf("%d", CalVolume(&st_MyPhPar)); //105
```

---

4. 指向函数
```c
int n = 6;
int array[n] = {0,1,2,3,4,5,6};
int SumFun(int *a)
{
  int sum = 0;
  for (int i = 0; i < n; i++)
  {
    sum += *a++;
  }
  return sum;
}

printf("%d", SumFun(array)); //21
```
---
---

# 指针与引用

指针和引用具有相似之处，他们都可以操作一个内容。
```c
int a = 1;
int b = 2;
int *p = &a; //指针
int &m = a;  //引用
m = 3;
printf("%d %d", a, *p); //3 3
p = &b;
printf("%d", *p); //2
```
引用需要注意：
（1）**引用定义时必须要初始化，明确引用对象；但指针可以是空指针**；
（2）**引用初始化后，不能改变引用对象；但指针可以改变指向的内容**。

引用的作用主要是传递函数中的参数和返回值。
```c
// 值传递
void Test1(int a)
{
  a++;
}
// 引用传递
void Test2(int &a)
{
  a++;
}
// 指针传递
void Test3(int *a)
{
  (*a)++;
}

int k1 = k2 = k3 = 0;
printf("K1: %d, K2: %d, k3: %d", Test1(k1), Test2(k2), Test3(k3));
//k1: 0, K2: 1, k3: 1
```
引用能做的事，指针也可以做，但是指针的权限太大，可能过导致一些不可预料的结果，因此能够用引用的地方使用引用，可以提高系统的稳定性。

---
---


# 指针与数组

指针和数组在许多应用上是相似的，但他们有很多区别。
数组在被创建时，其地址已经固定，只能改变数组的内容；数组可以创建在静态存储区和栈中。
指针可以指向任意的内存区，功能性很强大，但也更加危险，可能会导致内容泄露和野指针现象。

1. 修改内容
```c
char a[] = "hello";
char *p = "hello";

a[0] = 'm'; // a[] = "mello"
p[0] = 'm'; // 错误，指针p是真相常量"hello"，无法更改内容
```

---

2. 复制内容
指针和数组的复制，不能直接使用`b = a`和`b = p`来复制，因为a和p代表的是地址，这样复制过去的是地址而不是内容。所以需要使用标准库函数`strcpy`进行复制。
```c++
//数组
char a[] = "hello"; //""默认以'\0'结尾，所以有6个字符
char b[6];
strcpy(b, a);
cout << b << endl; // b[] = "hello"

//指针
char *p = (char *)malloc(6); //指针用于存储内容时，需要申请一块内存。空指针无法复制内容
strcpy(p, a);
count << p << endl; //p = "hello"
```

---

函数`strcpy`如何执行的，也建议了解一下，需要注意的是输入参数需要判断一下非空，提高系统的稳定性。
```c
char *strcpy(char *strDest, const char *strSrc)
{
  assert((strDest != NULL) && (strSrc != NULL));
  char *address = strDest;
  while(*strSrc != '\0')
  {
    *strDest++ = *strSrc++;
  }
  return address;
}
```

---
---

# 指针与内存

不可以使用函数的输入参数指针，去申请动态内存。
```c++
void ApplyMemory(char *p, int num)
{
  p = (char *)malloc(num);
}
char *a = NULL;
ApplyMemory(a, 6);
if (a == NULL)
{
  cout << "a = NULL" << endl;
}
```
函数中的指针，只能改变其内容，因为输入的实参a和形参p在编译的时候，是2个指针，指向同一个内容，在为p申请内存时，改变了p的地址，但a的地址并没有改变，因此a仍然为空指针。
并且为形参p申请的内存并没有释放，造成==内存泄露==。

---

因为函数的指针只能传递其内容，那么我们想要通过指针申请内容，是可以通过二级指针来达到目的的。
```c++
void ApplyMemory(char **p, int num)
{
  *p = (char *)malloc(num);
}

char *a = NULL;
ApplyMemory(&a, 6);
if (a != NULL)
{
  strcpy(a, "hello");
  cout << "a: " << a << endl;
  free(a);
}
```

---

如果不想用二级指针，可以利用函数返回值传递申请的内容地址。
```c
char *ApplyMemory(int num)
{
  char *p = (char *)malloc(num);
  return p;
}

char *a = NULL;
a = ApplyMemory(6);
if (a != NULL)
{
  strcpy(a, "hello");
  cout << "a: " << a << endl;
  free(a);
}
```

---

内存分为**堆区、栈区、静态区、代码区**，我们使用`malloc`申请的动态内存存储在堆区，长期有效，需要与`free`配合使用，两者的数量必须相同，否则会产生内存泄露。

需要注意的是，==`return`不能返回栈内存的指针==。
```c
char *ApplyMemory(void)
{
  char a[] = "hello";
  return a; //错误
}

char *b = NULL;
b = ApplyMemory();
cout << b << endl; //无法预测
```
栈内存在函数执行完成后，会自动消除，因此函数返回的地址所指向的内容是随机的，而不是"hello"。

---

## 野指针

什么是野指针？
野指针是指向垃圾内存的指针，它不是**NULL**指针，会对程序造成严重的影响，因为一般函数的输入参数只做非空判断，无法判断是否是野指针。

（1）指针变量没有初始化。
指针创建时，它的值时随机的，随意指向某个地方，可能是代码区、静态区等等，如果对其指向的内容进行改变，将会造成严重的后果。

```c
int *p = NULL;
int *a = (int *)malloc(sizeof(int) * 10);
```
创建时可以将指针设为空指针或者为其申请一个动态内存。

（2）指针被`free`释放后，没有置为**NULL**。
`free`只是释放了其指向的空间，并没有消除指针本身，它仍然指向之前所指向的地址。如果程序仍然对其内容进行改变，也会造成严重的后果。
```c
int *p = (int *)malloc(100);
strcpy(p, {0,1,2,3,4});
free(p);
p = NULL;
```
（3）指针操作超过了变量范围。
```c
char a[] = "hello";
char *p = a;
*(p+10) = 'a'; //错误

void Test(void)
{
  char b[] = "stack";
  p = b;
}

Test();//结束后，局部变量b被消除
cout << p << endl; //p是野指针
```

---

## 内存耗尽
如果内存耗尽后，`malloc`会返回**NULL**指针。
可以利用`return`终止本函数的运行，或者利用`exit(1)`终止整个程序的运行。
```c
void CheckMemory(void)
{
  char *p = (char *)malloc(1);
  if (p == NULL)
  {
    return; //终止本函数运行
    exit(1);//终止整个程序运行
  }
}
```
