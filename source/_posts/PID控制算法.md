---
title: PID控制算法
date: 2022/1/4
categories:
- 单片机
tags:
- 单片机

---


# 前言

PID即：Proportional（比例）、Integral（积分）、Differential（微分）的缩写。PID控制算法是结合比例、积分和微分三种环节于一体的控制算法。PID是闭环控制算法中最简单的一种，常应用于温度、电机控制等等。

---


# 原理

---


## 公式推导

PID公式：

$$
u(t) = K_p(e(t) + \frac{1}{T_i}\int_0^t {e(t)}dt + T_d \frac{de(t)}{dt})
$$

其中$K_p$为比例系数，$T_i$为积分时间，$T_d$为微分时间。

看公式就可以看出这是比例部分、积分部分和微分部分的加和，因此称为PID(proportion, integration, differential)。

在实际应用中，我们需要将该连续公式转化为离散公式，因此我们需要进行一下替换：

**连续时间t** $\longrightarrow$ **采样时间kT**

**积分**$\longrightarrow$ **求和**:     $\int_0^t {e(t)}\,{\rm d}t$ $\longrightarrow$ $T\sum_{j=0}^k e(j)$

**微分**$\longrightarrow$ **单位差值**： $\frac{de(t)}{dt}$  $\longrightarrow$ $\frac{e_k - e_{k-1}}{T}$

---

因为我们得到离散化的公式：
$$
u(k) = K_pe(k) + K_i\sum_{j=0}^ke(j) + K_d[e(k) - e(k-1)]
$$

其中$K_i = \frac{K_pT}{T_i}$，$K_d = \frac{K_pT_d}{T}$。



---



## 位置式PID

上面得到的公式，计算的值就是位置式PID，是当前负载应该输出的值。

比例项是对输出量起决定性作用的，当前值与目标值差值越大，则比例项越大。比例项越大，系统响应速度越快。

需要注意的是，公式中包含积分成分，因此仅适用于不包含积分效果的负载，即实时响应的，比如发热块。

并且在使用时，需要设置积分最大值，因为当误差一直为正时，积分项一直在累加，会导致积分项很大，当误差为负时，此时积分项不能及时减去，导致超调。

微分项的作用是抑制变化，误差为正时，微分项为负，误差为负时，微分项为正。微分具有预测的功能，它体现的是检测值的变化趋势，适当的值有利于稳定目标值。

==注：在调整PID参数时，应该先调P，再调I，最后调整D。==

---

## 增量式PID

顾名思义增量式就是当前输出量相比上一刻的输出量应该增加的值。

由公式2可以得出上一刻的公式：
$$
u(k-1) = K_pe(k-1) + K_i\sum_{j=0}^{k-1}e(j) + K_d[e(k-1) - e(k-2)]
$$
公式2和公式3相减得到：
$$
\bigtriangleup u(k) = K_p(e(k) - e(k-1)) + k_ie_k + K_d[e(k) - 2e(k-1) + e(k-2)]
$$

可以看出输出结果只与k, k-1, k-2时刻的反馈值有关，无积分作用。并且是作用于上一刻的控制量上的增加量。

增量式PID可以应用于带有积分结构的负载（如步进电机）。



---

# PID性能指标

在使用PID控制时，我们需要估算此时使用的PID参数实际应用的性能如何，能否达到要求，一般从以下几点观察。

---

---

## 超调量

顾名思义，超调量就是实际的反馈值超过设定值的量，它所占整个调整量的百分比。

![PID曲线](https://img-blog.csdnimg.cn/4ec96639bd024b2c8874bafda4590a46.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Iul5oKy5rWq,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

从图中可以看出，最大动态偏差（第一个波峰超过设定值的幅度）差不多是0.16，那么超调量为0.16/1 = 16%。

---

## 调节时间

调节时间是指从调整开始到稳态误差在要求范围内，所需要的时间，调节时间越短越好。

上图的调节时间大约在50左右。

---

## 震荡频率

震荡频率表现的是系统调整的速度，一般来说震荡频率越快越好，最后趋于平稳。

---

## 上升时间

上升时间是指实际值第一次达到设定值的时间，即快速上升阶段的时间，时间越短越好。



---



# PID算法改进

实际使用过程中，PID会有较大的局限性，导致调参过程中，根本无法达到要求，因此我们需要根据实际情况，进行改进。下面介绍几种常用的改进方法。

---

---

## 上下限设定法

有些场景下，并不希望全开或者全关，因此我们需要设置最大输出值和最小输出值，$u_{min} \leq u(t) \leq u_{max}$。

---

## 死区设定法

有时候，因为PID不断地调节，使得输出曲线不断震荡，当我们需要一个平稳的曲线时，我们可以在一段区间内，使负载不受PID控制，由固定功率运行，在区间外则重新受PID控制。

---

## 积分部分改进

我们知道积分部分是历史误差的和，既可以提高系统的响应速度，又可以帮助系统消除稳态误差。

当前值小于设定值时，积分项一直在累加，此时帮助输出值能够更快得达到设定值；但是当前值等于设定值时，比例项为0，积分项达到最大值，仍然会有输出，它会增大系统的超调量。

在当前值大于设定值时，积分项开始减小，帮助系统回到设定值。在只有比例项时，系统的振动幅度往往很大，加入积分项后，可以使系统更加稳定。

为了减小积分部分对超调量的影响，我们可以做出以下改进：

**设置积分项上限：**在第一个上升阶段，有较长的时间处于低于设定值的状态，积分项增加的很快，当当前值大于设定值时，又不能及时地减去积分项，因此我们可以设定一个积分项的最大值，使得积分项不至于累加过大。

**设置积分有效区间：**上面这种情况，我们也可以设置积分的有效区间，当当前值与设定值差值过大时，积分不进行累加，只有差值在一定的范围内时，积分开始累加，这样积分项不会累加的过大。也可以将在差值过大时的积分系数减小，达到相同的效果。

---

## 微分部分改进

微分部分是抑制系统输出值变化的，使系统更加稳定。它的趋势预测能力也可以帮助控制一些反馈滞后的系统，比如温度控制系统。但是微分部分往往是直接加上的，并且只持续一个时间周期，使得系统并不能稳定，且抗干扰能力减弱。

因此我们需要对微分部分进行一些改进措施：

---

## 不完全微分法

我们可以加入低通滤波器的方法，将微分项变得平缓一点。

下图是RC电路组成的一阶低通滤波器。
![RC低通滤波器](https://img-blog.csdnimg.cn/82ee19f594b24306b2fb25bf01447c7e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Iul5oKy5rWq,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center)

传递函数为：
$$
H(jw) = \frac{V_{out}}{V_{in}} = \frac{\frac{1}{jwC}}{R + \frac{1}{jwC}} = \frac{1}{1 + jwRC}
$$

$s = jw$，则
$$
H(s) = \frac{1}{1 + sRC}
$$

对s进行Z变化，这里采用一阶向后差分的方法：
$$
s = \frac{1 - z^{-1}}{T}
$$

---
推导过程如下：

令$\frac{U(s)}{E(s)} = \frac{1}{s}$，对其进行微分可以得到
$$
\frac{du(t)}{dt} = \frac{u(kT) - u[(k-1)T]}{T} = e(t)
$$

那么
$$
u(kT) = u[(k-1)T] + Te(kT)
$$

Z变换：
$$
U(z) = z^{-1}U(z) + TE(z)
$$

则
$$
s = \frac{E(s)}{U(s)} = \frac{E(z)}{U(z)} = \frac{1-z^{-1}}{T}
$$

---

带入公式(6)可以得到
$$
H(s) = \frac{1}{1 + \frac{1-z^{-1}}{T}RC} = \frac{T}{T + (1-z^{-1})RC}
$$

Z逆变换后
$$
(T + RC)V_{out}(n) - RCV_{out}(n-1) = TV_{in}(n)
$$

$$
\Rightarrow V_{out}(n) = \frac{TV_{in}(n) + RCV_{out}(n-1)}{T + RC} 
= V_{out}(n-1) + \frac{T}{T + RC}(V_{in}(n) - V_{out}(n-1))
$$


令$\alpha = \frac{T}{T + RC}$，则
$$
V_{out}(n) = \alpha V_{in}(n) + (1 - \alpha)V_{out}(n-1)
$$

将这个公式转换到PID微分项可以得到
$$
U_d(k) = \alpha K_d [e(k) - e(k-1)] + (1 - \alpha)U_d(k-1)
$$

**$\alpha$的取值为0~1，越小，滤波效果越大，当$\alpha = 0$时，没有微分效果，当$\alpha = 1$时，是没有滤波的微分，即完全微分。**

根据实际情况，选择合适的$\alpha$值。

---

公式(16)是位置式PID的微分算法，下面计算一下差值，即可得到增量式PID微分算法
$$
\bigtriangleup U_d(k) = \alpha K_d [e(k) - e(k-1)]  - \alpha U_d(k-1)
$$

---



## 微分先行法

前面的改善方法都是在设定值不变的情况，但是如果需要不断改变设定值的情况，使得被控量以一定规律波动。

以前面的方法，是对被控量与设定值的差值进行微分，设定值频繁改变时，微分项会产生较大的突变，影响系统稳定。

因此我们这里只对被控量进行微分，对设定值不进行微分。

微分先行法控制如图所示：

![PID微分先行](https://img-blog.csdnimg.cn/80773314d2c744d6a710f11bf768ec8e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Iul5oKy5rWq,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

我们令微分部分的传递函数为
$$
\frac{U_d(s)}{Y(s)} = \frac{T_ds + 1}{\gamma T_ds + 1} \qquad 0 < \gamma < 1
$$

则
$$
\gamma T_d \frac{du(t)}{dt} + u(t) = T_d \frac{dy(t)}{dt} + y(t)
$$

将微分部分一阶滞后差分：
$$
\frac{du(t)}{dt} = \frac{u(k) - u(k-1)}{T}
$$

$$
\frac{dy(t)}{dt} = \frac{y(k) - y(k-1)}{T}
$$

带入到公式(19)中得到：
$$
u_d(k) = \frac{\gamma T_d}{\gamma T_d + T} u_d(k-1) + \frac{T_d + T}{\gamma T_d + T} y(k) - \frac{T_d}{\gamma Td + T} y(k-1)
$$

将$K_d = \frac{K_pT_d}{T}$带入到上式中得到：

$$
u_d(k) = \frac{\gamma K_d}{\gamma K_d + K_p} u_d(k-1) + \frac{K_d + K_p}{\gamma K_d + K_p} y(k) - \frac{K_d}{\gamma K_d + K_p} y(k-1)
$$

上式为位置式PID的微分项，增量式PID的微分项如下：
$$
\bigtriangleup u_d(k) = -\frac{K_p}{\gamma K_d + K_p} u_d(k-1) + \frac{K_d + K_p}{\gamma K_d + K_p} y(k) - \frac{K_d}{\gamma K_d + K_p} y(k-1)
$$

---



