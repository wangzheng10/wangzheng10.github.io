---
title: 克鲁斯卡尔算法
date: 2022/5/07
categories:
- 数据结构
---

> 普利姆（Prim）算法是以某个顶点为起点，逐步寻找各个顶点上权值最小的边来构建生成树。
>
> 而克鲁斯卡尔（Kruskal）算法是以边为目标，直接寻找权值最小的边来构建生成树，并在构建中不形成回路。



# 一、定义

> 假设N = (V, {E})是一个连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T = {V, {}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。



---

# 二、实现思路

下图是一个连通网，我们以此来介绍普利姆算法的实现过程。

<img src="https://img-blog.csdnimg.cn/943f82132f1546f18ed9a10553420143.png#pic_center" alt="连通网" style="zoom:40%;" />

---

（1）首先设立最小生成树的初始状态T = {V, {}}，只有顶点，没有边，寻找权值最小的边，显然是$(v_1,v_5)$最小。

==注==：红色边为最小生成树的边，黑色线为连通网的边。

<center><img src="https://img-blog.csdnimg.cn/08738bd616984c52b6acd929051703c4.png" width="40%"></center>



（2）然后$(v_1,v_7)$边权值最小

<center><img src="https://img-blog.csdnimg.cn/24c63f195fa94be5add0a4df8b3a1332.png" width="40%"></center>



（3）此时有两条边的权值均为8，这里先取$(v_0,v_1)$边

<center><img src="https://img-blog.csdnimg.cn/3271649841894d2587e408833ff9ada9.png" width="40%"></center>

（4）添加$(v_4,v_5)$边

<center><img src="https://img-blog.csdnimg.cn/cfd8576eb908406fad96571d360ce4d5.png" width="40%"></center>


（5）添加$(v_3,v_7)$边

center><img src="https://img-blog.csdnimg.cn/be156c76e1d64234b0a1168bd46c3288.png" width="40%"></center>

（6）因为$(v_2,v_3)$边的两个顶点在同一连通分量中，如果添加此边，则会形成回路，所以添加$(v_0,v_5)$边

<center><img src="https://img-blog.csdnimg.cn/0c75027679814064a8d1067437a2969e.png" width="40%"></center>

（7）添加$(v_4,v_6)$边

<center><img src="https://img-blog.csdnimg.cn/778791562bda4af0a556beea41b4209b.png" width="40%"></center>




（8）添加$(v_5,v_8)$边

<center><img src="https://img-blog.csdnimg.cn/ce1e64ae29f84954890cb0b5880548cc.png" width="40%"></center>



此时所有顶点都在同一连通分量上，红色边所有顶点构造的树即为最小生成树。



---

# 三、程序解析



## 1. 临接矩阵转换为边集数组

（1）因为无向图的邻接矩阵是对称矩阵，那么边集数组只需要统计矩阵的右上半即可。`edge[]`用于存储图的每一条边。

（2）对边安装权值排序，由大到小，这里使用比较简单的冒泡排序法。

```c
//邻接矩阵转边集数组，按照权值排序，由小到大
void MGraph2EdgeArr(MGraph G, Edge* edge)
{
    int i, j, k=0;
    Edge temp;

    //将边数据填入edge中
    for (i = 0; i < G.numVertexes; i++)
    {
        for (j = i + 1; j < G.numVertexes; j++)
        {
            if (G.arc[i][j] != INFINITY)    //有边
            {
                edge[k].begin = i;
                edge[k].end = j;
                edge[k].weight = G.arc[i][j];
                k++;
            }
        }
    }
    //冒泡排序
    for (i = 0; i < k; i++)
    {
        for (j = i+1; j < k; j++)
        {
            if (edge[j].weight < edge[i].weight)
            {
                temp = edge[i];
                edge[i] = edge[j];
                edge[j] = temp;
            }
        }
    }
}
```



---



## 2. 克鲁斯卡尔算法程序



（1）`parent`数组：将同一连通分量的顶点串起来，下标为`edge.begin`，即各边的尾顶点下标，`parent`存储的值是边的头顶点下标，如果某一个顶点是两个边的尾，则在**上一个边的头顶点位置**存储**下一个边的头顶点下标**。

比如最小生成树依次添加了$(v_1,v_2)$，$(v_1,v_7)$，$(v_0,v_1)$，此时`parent`发生如下变化：

在添加$(v_1,v_7)$关系时，因为$parent[1] = 2$，$parent[2] = 0$，因此使$parent[2] = 7$。

![parent](https://img-blog.csdnimg.cn/c2eb604fab9447428ae0456410c4906c.png#pic_center)

如何判断两个顶点是否在同一连通分量呢？

可以根据`parent`观察，因为$parent[0] = 7,\ parent[7] = 0$，所以$v_0, v_7$在同一分量中，取名为连通分量A；因为$parent[1] = 2, \ parent[2] = 7$，所以$v_1, v_2, v_7$，它们均在连通分量A中。

我们只需要判断连线顶点的结尾顶点是否相同，如$v_1,v_2$连线均以$v_7$为结尾。



（2）按照权值从小到大遍历所有边，`Find`函数查找边的**两端顶点**所在的连通分量的**结尾顶点**，如果不同，则认为可以将此边添加到最小生成树中，不存在回路，打印该边信息。更新`parent`信息，将两个顶点所在的**连通分量**连接起来。



```c
void MiniSpanTree_Kruskal(MGraph G)
{
    int i, n, m;
    Edge edges[MAXEDGE]; //定义边集数组
    int parent[MAXEDGE]; //定义一数组用来判断边与边是否形成环路

    MGraph2EdgeArr(G, edges); //将邻接矩阵转换为边集数组

    for (i = 0; i < G.numEdges; i++)
    {
        parent[i] = 0; //初始化数组值为0
    }

    for (i = 0; i < G.numEdges; i++)
    {
        n = Find(parent, edges[i].begin);
        m = Find(parent, edges[i].end);
        if (n != m) //判断edges[i].begin和edges[i].end是否在同一连通分量中
        {
            parent[n] = m; //将edges[i].begin与edges[i].end连线
            printf(" (%d, %d) %d ", edges[i].begin, edges[i].end, edges[i].weight);
        }
    }
}

    
/* 查找连线顶点的尾部下标 */
int Find(int* parent, int f)
{
    while (parent[f] > 0)
    {
        f = parent[f];
    }
    return f;
}
```



## 3. 测试

```c
#include "CreateGraph.h"
#include "kruskal.h"

int main()
{

    MGraph G;
    CreateMgraph(&G);
    MiniSpanTree_Kruskal(G);
    
    return 0;
}
```



打印输出：

![kruskal_print](https://img-blog.csdnimg.cn/d15a4c5c19f7456d8cfd53bcc95f69e1.png#pic_center)



---

# 四、总结

> 因为Find函数的时间复杂度为$O(loge)$，e为连通网的边数，且for循环e次，则卡鲁斯卡尔的时间复杂度为$O(eloge)$。该算法主要针对边来展开，因此对于边数少的连通网来说，效率比较高。